/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/png-js@1.0.0";
exports.ids = ["vendor-chunks/png-js@1.0.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/png-js@1.0.0/node_modules/png-js/png-node.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/png-js@1.0.0/node_modules/png-js/png-node.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * MIT LICENSE\n * Copyright (c) 2011 Devon Govett\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nmodule.exports = class PNG {\n  static decode(path, fn) {\n    return fs.readFile(path, function(err, file) {\n      const png = new PNG(file);\n      return png.decode(pixels => fn(pixels));\n    });\n  }\n\n  static load(path) {\n    const file = fs.readFileSync(path);\n    return new PNG(file);\n  }\n\n  constructor(data) {\n    let i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      const chunkSize = this.readUInt32();\n      let section = '';\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n              break;\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(\n            String,\n            text.slice(index + 1)\n          );\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n\n  read(bytes) {\n    const result = new Array(bytes);\n    for (let i = 0; i < bytes; i++) {\n      result[i] = this.data[this.pos++];\n    }\n    return result;\n  }\n\n  readUInt32() {\n    const b1 = this.data[this.pos++] << 24;\n    const b2 = this.data[this.pos++] << 16;\n    const b3 = this.data[this.pos++] << 8;\n    const b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  }\n\n  readUInt16() {\n    const b1 = this.data[this.pos++] << 8;\n    const b2 = this.data[this.pos++];\n    return b1 | b2;\n  }\n\n  decodePixels(fn) {\n    return zlib.inflate(this.imgData, (err, data) => {\n      if (err) {\n        throw err;\n      }\n\n      const { width, height } = this;\n      const pixelBytes = this.pixelBitlength / 8;\n\n      const pixels = new Buffer(width * height * pixelBytes);\n      const { length } = data;\n      let pos = 0;\n\n      function pass(x0, y0, dx, dy, singlePass = false) {\n        const w = Math.ceil((width - x0) / dx);\n        const h = Math.ceil((height - y0) / dy);\n        const scanlineLength = pixelBytes * w;\n        const buffer = singlePass ? pixels : new Buffer(scanlineLength * h);\n        let row = 0;\n        let c = 0;\n        while (row < h && pos < length) {\n          var byte, col, i, left, upper;\n          switch (data[pos++]) {\n            case 0: // None\n              for (i = 0; i < scanlineLength; i++) {\n                buffer[c++] = data[pos++];\n              }\n              break;\n\n            case 1: // Sub\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                buffer[c++] = (byte + left) % 256;\n              }\n              break;\n\n            case 2: // Up\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                upper =\n                  row &&\n                  buffer[\n                    (row - 1) * scanlineLength +\n                      col * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n                buffer[c++] = (upper + byte) % 256;\n              }\n              break;\n\n            case 3: // Average\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                upper =\n                  row &&\n                  buffer[\n                    (row - 1) * scanlineLength +\n                      col * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n              break;\n\n            case 4: // Paeth\n              for (i = 0; i < scanlineLength; i++) {\n                var paeth, upperLeft;\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper =\n                    buffer[\n                      (row - 1) * scanlineLength +\n                        col * pixelBytes +\n                        (i % pixelBytes)\n                    ];\n                  upperLeft =\n                    col &&\n                    buffer[\n                      (row - 1) * scanlineLength +\n                        (col - 1) * pixelBytes +\n                        (i % pixelBytes)\n                    ];\n                }\n\n                const p = left + upper - upperLeft;\n                const pa = Math.abs(p - left);\n                const pb = Math.abs(p - upper);\n                const pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                buffer[c++] = (byte + paeth) % 256;\n              }\n              break;\n\n            default:\n              throw new Error(`Invalid filter algorithm: ${data[pos - 1]}`);\n          }\n\n          if (!singlePass) {\n            let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n            let bufferPos = row * scanlineLength;\n            for (i = 0; i < w; i++) {\n              for (let j = 0; j < pixelBytes; j++)\n                pixels[pixelsPos++] = buffer[bufferPos++];\n              pixelsPos += (dx - 1) * pixelBytes;\n            }\n          }\n\n          row++;\n        }\n      }\n\n      if (this.interlaceMethod === 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n        pass(4, 0, 8, 8); // 2\n        pass(0, 4, 4, 8); // 3\n        pass(2, 0, 4, 4); // 4\n        pass(0, 2, 2, 4); // 5\n        pass(1, 0, 2, 2); // 6\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1, true);\n      }\n\n      return fn(pixels);\n    });\n  }\n\n  decodePalette() {\n    const { palette } = this;\n    const { length } = palette;\n    const transparency = this.transparency.indexed || [];\n    const ret = new Buffer(transparency.length + length);\n    let pos = 0;\n    let c = 0;\n\n    for (let i = 0; i < length; i += 3) {\n      var left;\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n    }\n\n    return ret;\n  }\n\n  copyToImageData(imageData, pixels) {\n    let j, k;\n    let { colors } = this;\n    let palette = null;\n    let alpha = this.hasAlphaChannel;\n\n    if (this.palette.length) {\n      palette =\n        this._decodedPalette || (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n\n    const data = imageData.data || imageData;\n    const { length } = data;\n    const input = palette || pixels;\n    let i = (j = 0);\n\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        const v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  }\n\n  decode(fn) {\n    const ret = new Buffer(this.width * this.height * 4);\n    return this.decodePixels(pixels => {\n      this.copyToImageData(ret, pixels);\n      return fn(ret);\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcG5nLWpzQDEuMC4wL25vZGVfbW9kdWxlcy9wbmctanMvcG5nLW5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsZ0JBQWdCO0FBQzlCOztBQUVBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQW9CO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsY0FBYztBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQiw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvb2JlZGthZmZsdS9Eb2N1bWVudHMvR2l0SHViL3NlZWRjbHViL25vZGVfbW9kdWxlcy8ucG5wbS9wbmctanNAMS4wLjAvbm9kZV9tb2R1bGVzL3BuZy1qcy9wbmctbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogTUlUIExJQ0VOU0VcbiAqIENvcHlyaWdodCAoYykgMjAxMSBEZXZvbiBHb3ZldHRcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbiAqIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuICogd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29uc1xuICogdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yXG4gKiBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkdcbiAqIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbiAqIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUE5HIHtcbiAgc3RhdGljIGRlY29kZShwYXRoLCBmbikge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZShwYXRoLCBmdW5jdGlvbihlcnIsIGZpbGUpIHtcbiAgICAgIGNvbnN0IHBuZyA9IG5ldyBQTkcoZmlsZSk7XG4gICAgICByZXR1cm4gcG5nLmRlY29kZShwaXhlbHMgPT4gZm4ocGl4ZWxzKSk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgbG9hZChwYXRoKSB7XG4gICAgY29uc3QgZmlsZSA9IGZzLnJlYWRGaWxlU3luYyhwYXRoKTtcbiAgICByZXR1cm4gbmV3IFBORyhmaWxlKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBsZXQgaTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMucG9zID0gODsgLy8gU2tpcCB0aGUgZGVmYXVsdCBoZWFkZXJcblxuICAgIHRoaXMucGFsZXR0ZSA9IFtdO1xuICAgIHRoaXMuaW1nRGF0YSA9IFtdO1xuICAgIHRoaXMudHJhbnNwYXJlbmN5ID0ge307XG4gICAgdGhpcy50ZXh0ID0ge307XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5yZWFkVUludDMyKCk7XG4gICAgICBsZXQgc2VjdGlvbiA9ICcnO1xuICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBzZWN0aW9uICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5kYXRhW3RoaXMucG9zKytdKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChzZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgJ0lIRFInOlxuICAgICAgICAgIC8vIHdlIGNhbiBncmFiICBpbnRlcmVzdGluZyB2YWx1ZXMgZnJvbSBoZXJlIChsaWtlIHdpZHRoLCBoZWlnaHQsIGV0YylcbiAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5yZWFkVUludDMyKCk7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnJlYWRVSW50MzIoKTtcbiAgICAgICAgICB0aGlzLmJpdHMgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgdGhpcy5jb2xvclR5cGUgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgdGhpcy5jb21wcmVzc2lvbk1ldGhvZCA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICAgICAgICB0aGlzLmZpbHRlck1ldGhvZCA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICAgICAgICB0aGlzLmludGVybGFjZU1ldGhvZCA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQTFRFJzpcbiAgICAgICAgICB0aGlzLnBhbGV0dGUgPSB0aGlzLnJlYWQoY2h1bmtTaXplKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdJREFUJzpcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2h1bmtTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW1nRGF0YS5wdXNoKHRoaXMuZGF0YVt0aGlzLnBvcysrXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RSTlMnOlxuICAgICAgICAgIC8vIFRoaXMgY2h1bmsgY2FuIG9ubHkgb2NjdXIgb25jZSBhbmQgaXQgbXVzdCBvY2N1ciBhZnRlciB0aGVcbiAgICAgICAgICAvLyBQTFRFIGNodW5rIGFuZCBiZWZvcmUgdGhlIElEQVQgY2h1bmsuXG4gICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3kgPSB7fTtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuY29sb3JUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIC8vIEluZGV4ZWQgY29sb3IsIFJHQi4gRWFjaCBieXRlIGluIHRoaXMgY2h1bmsgaXMgYW4gYWxwaGEgZm9yXG4gICAgICAgICAgICAgIC8vIHRoZSBwYWxldHRlIGluZGV4IGluIHRoZSBQTFRFIChcInBhbGV0dGVcIikgY2h1bmsgdXAgdW50aWwgdGhlXG4gICAgICAgICAgICAgIC8vIGxhc3Qgbm9uLW9wYXF1ZSBlbnRyeS4gU2V0IHVwIGFuIGFycmF5LCBzdHJldGNoaW5nIG92ZXIgYWxsXG4gICAgICAgICAgICAgIC8vIHBhbGV0dGUgZW50cmllcyB3aGljaCB3aWxsIGJlIDAgKG9wYXF1ZSkgb3IgMSAodHJhbnNwYXJlbnQpLlxuICAgICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeS5pbmRleGVkID0gdGhpcy5yZWFkKGNodW5rU2l6ZSk7XG4gICAgICAgICAgICAgIHZhciBzaG9ydCA9IDI1NSAtIHRoaXMudHJhbnNwYXJlbmN5LmluZGV4ZWQubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoc2hvcnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNob3J0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5LmluZGV4ZWQucHVzaCgyNTUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgLy8gR3JleXNjYWxlLiBDb3JyZXNwb25kaW5nIHRvIGVudHJpZXMgaW4gdGhlIFBMVEUgY2h1bmsuXG4gICAgICAgICAgICAgIC8vIEdyZXkgaXMgdHdvIGJ5dGVzLCByYW5nZSAwIC4uICgyIF4gYml0LWRlcHRoKSAtIDFcbiAgICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3kuZ3JheXNjYWxlID0gdGhpcy5yZWFkKGNodW5rU2l6ZSlbMF07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAvLyBUcnVlIGNvbG9yIHdpdGggcHJvcGVyIGFscGhhIGNoYW5uZWwuXG4gICAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5LnJnYiA9IHRoaXMucmVhZChjaHVua1NpemUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndEVYdCc6XG4gICAgICAgICAgdmFyIHRleHQgPSB0aGlzLnJlYWQoY2h1bmtTaXplKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSB0ZXh0LmluZGV4T2YoMCk7XG4gICAgICAgICAgdmFyIGtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB0ZXh0LnNsaWNlKDAsIGluZGV4KSk7XG4gICAgICAgICAgdGhpcy50ZXh0W2tleV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgICAgICAgU3RyaW5nLFxuICAgICAgICAgICAgdGV4dC5zbGljZShpbmRleCArIDEpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdJRU5EJzpcbiAgICAgICAgICAvLyB3ZSd2ZSBnb3QgZXZlcnl0aGluZyB3ZSBuZWVkIVxuICAgICAgICAgIHN3aXRjaCAodGhpcy5jb2xvclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgdGhpcy5jb2xvcnMgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgdGhpcy5jb2xvcnMgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmhhc0FscGhhQ2hhbm5lbCA9IFs0LCA2XS5pbmNsdWRlcyh0aGlzLmNvbG9yVHlwZSk7XG4gICAgICAgICAgdmFyIGNvbG9ycyA9IHRoaXMuY29sb3JzICsgKHRoaXMuaGFzQWxwaGFDaGFubmVsID8gMSA6IDApO1xuICAgICAgICAgIHRoaXMucGl4ZWxCaXRsZW5ndGggPSB0aGlzLmJpdHMgKiBjb2xvcnM7XG5cbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuY29sb3JzKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHRoaXMuY29sb3JTcGFjZSA9ICdEZXZpY2VHcmF5JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHRoaXMuY29sb3JTcGFjZSA9ICdEZXZpY2VSR0InO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmltZ0RhdGEgPSBuZXcgQnVmZmVyKHRoaXMuaW1nRGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gdW5rbm93biAob3IgdW5pbXBvcnRhbnQpIHNlY3Rpb24sIHNraXAgaXRcbiAgICAgICAgICB0aGlzLnBvcyArPSBjaHVua1NpemU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9zICs9IDQ7IC8vIFNraXAgdGhlIENSQ1xuXG4gICAgICBpZiAodGhpcy5wb3MgPiB0aGlzLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wbGV0ZSBvciBjb3JydXB0IFBORyBmaWxlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVhZChieXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShieXRlcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZWFkVUludDMyKCkge1xuICAgIGNvbnN0IGIxID0gdGhpcy5kYXRhW3RoaXMucG9zKytdIDw8IDI0O1xuICAgIGNvbnN0IGIyID0gdGhpcy5kYXRhW3RoaXMucG9zKytdIDw8IDE2O1xuICAgIGNvbnN0IGIzID0gdGhpcy5kYXRhW3RoaXMucG9zKytdIDw8IDg7XG4gICAgY29uc3QgYjQgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgcmV0dXJuIGIxIHwgYjIgfCBiMyB8IGI0O1xuICB9XG5cbiAgcmVhZFVJbnQxNigpIHtcbiAgICBjb25zdCBiMSA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXSA8PCA4O1xuICAgIGNvbnN0IGIyID0gdGhpcy5kYXRhW3RoaXMucG9zKytdO1xuICAgIHJldHVybiBiMSB8IGIyO1xuICB9XG5cbiAgZGVjb2RlUGl4ZWxzKGZuKSB7XG4gICAgcmV0dXJuIHpsaWIuaW5mbGF0ZSh0aGlzLmltZ0RhdGEsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG4gICAgICBjb25zdCBwaXhlbEJ5dGVzID0gdGhpcy5waXhlbEJpdGxlbmd0aCAvIDg7XG5cbiAgICAgIGNvbnN0IHBpeGVscyA9IG5ldyBCdWZmZXIod2lkdGggKiBoZWlnaHQgKiBwaXhlbEJ5dGVzKTtcbiAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBkYXRhO1xuICAgICAgbGV0IHBvcyA9IDA7XG5cbiAgICAgIGZ1bmN0aW9uIHBhc3MoeDAsIHkwLCBkeCwgZHksIHNpbmdsZVBhc3MgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB3ID0gTWF0aC5jZWlsKCh3aWR0aCAtIHgwKSAvIGR4KTtcbiAgICAgICAgY29uc3QgaCA9IE1hdGguY2VpbCgoaGVpZ2h0IC0geTApIC8gZHkpO1xuICAgICAgICBjb25zdCBzY2FubGluZUxlbmd0aCA9IHBpeGVsQnl0ZXMgKiB3O1xuICAgICAgICBjb25zdCBidWZmZXIgPSBzaW5nbGVQYXNzID8gcGl4ZWxzIDogbmV3IEJ1ZmZlcihzY2FubGluZUxlbmd0aCAqIGgpO1xuICAgICAgICBsZXQgcm93ID0gMDtcbiAgICAgICAgbGV0IGMgPSAwO1xuICAgICAgICB3aGlsZSAocm93IDwgaCAmJiBwb3MgPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgYnl0ZSwgY29sLCBpLCBsZWZ0LCB1cHBlcjtcbiAgICAgICAgICBzd2l0Y2ggKGRhdGFbcG9zKytdKSB7XG4gICAgICAgICAgICBjYXNlIDA6IC8vIE5vbmVcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYW5saW5lTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBidWZmZXJbYysrXSA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE6IC8vIFN1YlxuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbmxpbmVMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGUgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gaSA8IHBpeGVsQnl0ZXMgPyAwIDogYnVmZmVyW2MgLSBwaXhlbEJ5dGVzXTtcbiAgICAgICAgICAgICAgICBidWZmZXJbYysrXSA9IChieXRlICsgbGVmdCkgJSAyNTY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjogLy8gVXBcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYW5saW5lTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBieXRlID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICAgICAgY29sID0gKGkgLSAoaSAlIHBpeGVsQnl0ZXMpKSAvIHBpeGVsQnl0ZXM7XG4gICAgICAgICAgICAgICAgdXBwZXIgPVxuICAgICAgICAgICAgICAgICAgcm93ICYmXG4gICAgICAgICAgICAgICAgICBidWZmZXJbXG4gICAgICAgICAgICAgICAgICAgIChyb3cgLSAxKSAqIHNjYW5saW5lTGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgICBjb2wgKiBwaXhlbEJ5dGVzICtcbiAgICAgICAgICAgICAgICAgICAgICAoaSAlIHBpeGVsQnl0ZXMpXG4gICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltjKytdID0gKHVwcGVyICsgYnl0ZSkgJSAyNTY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzogLy8gQXZlcmFnZVxuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbmxpbmVMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGUgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgICAgICBjb2wgPSAoaSAtIChpICUgcGl4ZWxCeXRlcykpIC8gcGl4ZWxCeXRlcztcbiAgICAgICAgICAgICAgICBsZWZ0ID0gaSA8IHBpeGVsQnl0ZXMgPyAwIDogYnVmZmVyW2MgLSBwaXhlbEJ5dGVzXTtcbiAgICAgICAgICAgICAgICB1cHBlciA9XG4gICAgICAgICAgICAgICAgICByb3cgJiZcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlcltcbiAgICAgICAgICAgICAgICAgICAgKHJvdyAtIDEpICogc2NhbmxpbmVMZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICAgIGNvbCAqIHBpeGVsQnl0ZXMgK1xuICAgICAgICAgICAgICAgICAgICAgIChpICUgcGl4ZWxCeXRlcylcbiAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgYnVmZmVyW2MrK10gPSAoYnl0ZSArIE1hdGguZmxvb3IoKGxlZnQgKyB1cHBlcikgLyAyKSkgJSAyNTY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDogLy8gUGFldGhcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYW5saW5lTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFldGgsIHVwcGVyTGVmdDtcbiAgICAgICAgICAgICAgICBieXRlID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICAgICAgY29sID0gKGkgLSAoaSAlIHBpeGVsQnl0ZXMpKSAvIHBpeGVsQnl0ZXM7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGkgPCBwaXhlbEJ5dGVzID8gMCA6IGJ1ZmZlcltjIC0gcGl4ZWxCeXRlc107XG5cbiAgICAgICAgICAgICAgICBpZiAocm93ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICB1cHBlciA9IHVwcGVyTGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHVwcGVyID1cbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW1xuICAgICAgICAgICAgICAgICAgICAgIChyb3cgLSAxKSAqIHNjYW5saW5lTGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCAqIHBpeGVsQnl0ZXMgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGkgJSBwaXhlbEJ5dGVzKVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgdXBwZXJMZWZ0ID1cbiAgICAgICAgICAgICAgICAgICAgY29sICYmXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltcbiAgICAgICAgICAgICAgICAgICAgICAocm93IC0gMSkgKiBzY2FubGluZUxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29sIC0gMSkgKiBwaXhlbEJ5dGVzICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChpICUgcGl4ZWxCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwID0gbGVmdCArIHVwcGVyIC0gdXBwZXJMZWZ0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhID0gTWF0aC5hYnMocCAtIGxlZnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBiID0gTWF0aC5hYnMocCAtIHVwcGVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYyA9IE1hdGguYWJzKHAgLSB1cHBlckxlZnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhIDw9IHBiICYmIHBhIDw9IHBjKSB7XG4gICAgICAgICAgICAgICAgICBwYWV0aCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYiA8PSBwYykge1xuICAgICAgICAgICAgICAgICAgcGFldGggPSB1cHBlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFldGggPSB1cHBlckxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnVmZmVyW2MrK10gPSAoYnl0ZSArIHBhZXRoKSAlIDI1NjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpbHRlciBhbGdvcml0aG06ICR7ZGF0YVtwb3MgLSAxXX1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXNpbmdsZVBhc3MpIHtcbiAgICAgICAgICAgIGxldCBwaXhlbHNQb3MgPSAoKHkwICsgcm93ICogZHkpICogd2lkdGggKyB4MCkgKiBwaXhlbEJ5dGVzO1xuICAgICAgICAgICAgbGV0IGJ1ZmZlclBvcyA9IHJvdyAqIHNjYW5saW5lTGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHc7IGkrKykge1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBpeGVsQnl0ZXM7IGorKylcbiAgICAgICAgICAgICAgICBwaXhlbHNbcGl4ZWxzUG9zKytdID0gYnVmZmVyW2J1ZmZlclBvcysrXTtcbiAgICAgICAgICAgICAgcGl4ZWxzUG9zICs9IChkeCAtIDEpICogcGl4ZWxCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3crKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbnRlcmxhY2VNZXRob2QgPT09IDEpIHtcbiAgICAgICAgLypcbiAgICAgICAgICAxIDYgNCA2IDIgNiA0IDZcbiAgICAgICAgICA3IDcgNyA3IDcgNyA3IDdcbiAgICAgICAgICA1IDYgNSA2IDUgNiA1IDZcbiAgICAgICAgICA3IDcgNyA3IDcgNyA3IDdcbiAgICAgICAgICAzIDYgNCA2IDMgNiA0IDZcbiAgICAgICAgICA3IDcgNyA3IDcgNyA3IDdcbiAgICAgICAgICA1IDYgNSA2IDUgNiA1IDZcbiAgICAgICAgICA3IDcgNyA3IDcgNyA3IDdcbiAgICAgICAgKi9cbiAgICAgICAgcGFzcygwLCAwLCA4LCA4KTsgLy8gMVxuICAgICAgICBwYXNzKDQsIDAsIDgsIDgpOyAvLyAyXG4gICAgICAgIHBhc3MoMCwgNCwgNCwgOCk7IC8vIDNcbiAgICAgICAgcGFzcygyLCAwLCA0LCA0KTsgLy8gNFxuICAgICAgICBwYXNzKDAsIDIsIDIsIDQpOyAvLyA1XG4gICAgICAgIHBhc3MoMSwgMCwgMiwgMik7IC8vIDZcbiAgICAgICAgcGFzcygwLCAxLCAxLCAyKTsgLy8gN1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFzcygwLCAwLCAxLCAxLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuKHBpeGVscyk7XG4gICAgfSk7XG4gIH1cblxuICBkZWNvZGVQYWxldHRlKCkge1xuICAgIGNvbnN0IHsgcGFsZXR0ZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gcGFsZXR0ZTtcbiAgICBjb25zdCB0cmFuc3BhcmVuY3kgPSB0aGlzLnRyYW5zcGFyZW5jeS5pbmRleGVkIHx8IFtdO1xuICAgIGNvbnN0IHJldCA9IG5ldyBCdWZmZXIodHJhbnNwYXJlbmN5Lmxlbmd0aCArIGxlbmd0aCk7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgbGV0IGMgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuICAgICAgdmFyIGxlZnQ7XG4gICAgICByZXRbcG9zKytdID0gcGFsZXR0ZVtpXTtcbiAgICAgIHJldFtwb3MrK10gPSBwYWxldHRlW2kgKyAxXTtcbiAgICAgIHJldFtwb3MrK10gPSBwYWxldHRlW2kgKyAyXTtcbiAgICAgIHJldFtwb3MrK10gPSAobGVmdCA9IHRyYW5zcGFyZW5jeVtjKytdKSAhPSBudWxsID8gbGVmdCA6IDI1NTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgY29weVRvSW1hZ2VEYXRhKGltYWdlRGF0YSwgcGl4ZWxzKSB7XG4gICAgbGV0IGosIGs7XG4gICAgbGV0IHsgY29sb3JzIH0gPSB0aGlzO1xuICAgIGxldCBwYWxldHRlID0gbnVsbDtcbiAgICBsZXQgYWxwaGEgPSB0aGlzLmhhc0FscGhhQ2hhbm5lbDtcblxuICAgIGlmICh0aGlzLnBhbGV0dGUubGVuZ3RoKSB7XG4gICAgICBwYWxldHRlID1cbiAgICAgICAgdGhpcy5fZGVjb2RlZFBhbGV0dGUgfHwgKHRoaXMuX2RlY29kZWRQYWxldHRlID0gdGhpcy5kZWNvZGVQYWxldHRlKCkpO1xuICAgICAgY29sb3JzID0gNDtcbiAgICAgIGFscGhhID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGEgfHwgaW1hZ2VEYXRhO1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBkYXRhO1xuICAgIGNvbnN0IGlucHV0ID0gcGFsZXR0ZSB8fCBwaXhlbHM7XG4gICAgbGV0IGkgPSAoaiA9IDApO1xuXG4gICAgaWYgKGNvbG9ycyA9PT0gMSkge1xuICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgayA9IHBhbGV0dGUgPyBwaXhlbHNbaSAvIDRdICogNCA6IGo7XG4gICAgICAgIGNvbnN0IHYgPSBpbnB1dFtrKytdO1xuICAgICAgICBkYXRhW2krK10gPSB2O1xuICAgICAgICBkYXRhW2krK10gPSB2O1xuICAgICAgICBkYXRhW2krK10gPSB2O1xuICAgICAgICBkYXRhW2krK10gPSBhbHBoYSA/IGlucHV0W2srK10gOiAyNTU7XG4gICAgICAgIGogPSBrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBrID0gcGFsZXR0ZSA/IHBpeGVsc1tpIC8gNF0gKiA0IDogajtcbiAgICAgICAgZGF0YVtpKytdID0gaW5wdXRbaysrXTtcbiAgICAgICAgZGF0YVtpKytdID0gaW5wdXRbaysrXTtcbiAgICAgICAgZGF0YVtpKytdID0gaW5wdXRbaysrXTtcbiAgICAgICAgZGF0YVtpKytdID0gYWxwaGEgPyBpbnB1dFtrKytdIDogMjU1O1xuICAgICAgICBqID0gaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWNvZGUoZm4pIHtcbiAgICBjb25zdCByZXQgPSBuZXcgQnVmZmVyKHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIDQpO1xuICAgIHJldHVybiB0aGlzLmRlY29kZVBpeGVscyhwaXhlbHMgPT4ge1xuICAgICAgdGhpcy5jb3B5VG9JbWFnZURhdGEocmV0LCBwaXhlbHMpO1xuICAgICAgcmV0dXJuIGZuKHJldCk7XG4gICAgfSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/png-js@1.0.0/node_modules/png-js/png-node.js\n");

/***/ })

};
;
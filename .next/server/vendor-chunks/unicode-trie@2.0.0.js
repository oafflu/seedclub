/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/unicode-trie@2.0.0";
exports.ids = ["vendor-chunks/unicode-trie@2.0.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/index.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const inflate = __webpack_require__(/*! tiny-inflate */ \"(rsc)/./node_modules/.pnpm/tiny-inflate@1.0.3/node_modules/tiny-inflate/index.js\");\nconst { swap32LE } = __webpack_require__(/*! ./swap */ \"(rsc)/./node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/swap.js\");\n\n// Shift size for getting the index-1 table offset.\nconst SHIFT_1 = 6 + 5;\n\n// Shift size for getting the index-2 table offset.\nconst SHIFT_2 = 5;\n\n// Difference between the two shift sizes,\n// for getting an index-1 offset from an index-2 offset. 6=11-5\nconst SHIFT_1_2 = SHIFT_1 - SHIFT_2;\n\n// Number of index-1 entries for the BMP. 32=0x20\n// This part of the index-1 table is omitted from the serialized form.\nconst OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> SHIFT_1;\n\n// Number of entries in an index-2 block. 64=0x40\nconst INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;\n\n// Mask for getting the lower bits for the in-index-2-block offset. */\nconst INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;\n\n// Shift size for shifting left the index array values.\n// Increases possible data size with 16-bit index values at the cost\n// of compactability.\n// This requires data blocks to be aligned by DATA_GRANULARITY.\nconst INDEX_SHIFT = 2;\n\n// Number of entries in a data block. 32=0x20\nconst DATA_BLOCK_LENGTH = 1 << SHIFT_2;\n\n// Mask for getting the lower bits for the in-data-block offset.\nconst DATA_MASK = DATA_BLOCK_LENGTH - 1;\n\n// The part of the index-2 table for U+D800..U+DBFF stores values for\n// lead surrogate code _units_ not code _points_.\n// Values for lead surrogate code _points_ are indexed with this portion of the table.\n// Length=32=0x20=0x400>>SHIFT_2. (There are 1024=0x400 lead surrogates.)\nconst LSCP_INDEX_2_OFFSET = 0x10000 >> SHIFT_2;\nconst LSCP_INDEX_2_LENGTH = 0x400 >> SHIFT_2;\n\n// Count the lengths of both BMP pieces. 2080=0x820\nconst INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;\n\n// The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.\n// Length 32=0x20 for lead bytes C0..DF, regardless of SHIFT_2.\nconst UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;\nconst UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6;  // U+0800 is the first code point after 2-byte UTF-8\n\n// The index-1 table, only used for supplementary code points, at offset 2112=0x840.\n// Variable length, for code points up to highStart, where the last single-value range starts.\n// Maximum length 512=0x200=0x100000>>SHIFT_1.\n// (For 0x100000 supplementary code points U+10000..U+10ffff.)\n//\n// The part of the index-2 table for supplementary code points starts\n// after this index-1 table.\n//\n// Both the index-1 table and the following part of the index-2 table\n// are omitted completely if there is only BMP data.\nconst INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;\n\n// The alignment size of a data block. Also the granularity for compaction.\nconst DATA_GRANULARITY = 1 << INDEX_SHIFT;\n\nclass UnicodeTrie {\n  constructor(data) {\n    const isBuffer = (typeof data.readUInt32BE === 'function') && (typeof data.slice === 'function');\n\n    if (isBuffer || data instanceof Uint8Array) {\n      // read binary format\n      let uncompressedLength;\n      if (isBuffer) {\n        this.highStart = data.readUInt32LE(0);\n        this.errorValue = data.readUInt32LE(4);\n        uncompressedLength = data.readUInt32LE(8);\n        data = data.slice(12);\n      } else {\n        const view = new DataView(data.buffer);\n        this.highStart = view.getUint32(0, true);\n        this.errorValue = view.getUint32(4, true);\n        uncompressedLength = view.getUint32(8, true);\n        data = data.subarray(12);\n      }\n\n      // double inflate the actual trie data\n      data = inflate(data, new Uint8Array(uncompressedLength));\n      data = inflate(data, new Uint8Array(uncompressedLength));\n\n      // swap bytes from little-endian\n      swap32LE(data);\n\n      this.data = new Uint32Array(data.buffer);\n\n    } else {\n      // pre-parsed data\n      ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data);\n    }\n  }\n\n  get(codePoint) {\n    let index;\n    if ((codePoint < 0) || (codePoint > 0x10ffff)) {\n      return this.errorValue;\n    }\n\n    if ((codePoint < 0xd800) || ((codePoint > 0xdbff) && (codePoint <= 0xffff))) {\n      // Ordinary BMP code point, excluding leading surrogates.\n      // BMP uses a single level lookup.  BMP index starts at offset 0 in the index.\n      // data is stored in the index array itself.\n      index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);\n      return this.data[index];\n    }\n\n    if (codePoint <= 0xffff) {\n      // Lead Surrogate Code Point.  A Separate index section is stored for\n      // lead surrogate code units and code points.\n      //   The main index has the code unit data.\n      //   For this function, we need the code point data.\n      index = (this.data[LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);\n      return this.data[index];\n    }\n\n    if (codePoint < this.highStart) {\n      // Supplemental code point, use two-level lookup.\n      index = this.data[(INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH) + (codePoint >> SHIFT_1)];\n      index = this.data[index + ((codePoint >> SHIFT_2) & INDEX_2_MASK)];\n      index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);\n      return this.data[index];\n    }\n\n    return this.data[this.data.length - DATA_GRANULARITY];\n  }\n}\n\nmodule.exports = UnicodeTrie;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vdW5pY29kZS10cmllQDIuMC4wL25vZGVfbW9kdWxlcy91bmljb2RlLXRyaWUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsc0dBQWM7QUFDdEMsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQywrRkFBUTs7QUFFckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxNQUFNO0FBQ047QUFDQSxTQUFTLDBFQUEwRTtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9vYmVka2FmZmx1L0RvY3VtZW50cy9HaXRIdWIvc2VlZGNsdWIvbm9kZV9tb2R1bGVzLy5wbnBtL3VuaWNvZGUtdHJpZUAyLjAuMC9ub2RlX21vZHVsZXMvdW5pY29kZS10cmllL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGluZmxhdGUgPSByZXF1aXJlKCd0aW55LWluZmxhdGUnKTtcbmNvbnN0IHsgc3dhcDMyTEUgfSA9IHJlcXVpcmUoJy4vc3dhcCcpO1xuXG4vLyBTaGlmdCBzaXplIGZvciBnZXR0aW5nIHRoZSBpbmRleC0xIHRhYmxlIG9mZnNldC5cbmNvbnN0IFNISUZUXzEgPSA2ICsgNTtcblxuLy8gU2hpZnQgc2l6ZSBmb3IgZ2V0dGluZyB0aGUgaW5kZXgtMiB0YWJsZSBvZmZzZXQuXG5jb25zdCBTSElGVF8yID0gNTtcblxuLy8gRGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gc2hpZnQgc2l6ZXMsXG4vLyBmb3IgZ2V0dGluZyBhbiBpbmRleC0xIG9mZnNldCBmcm9tIGFuIGluZGV4LTIgb2Zmc2V0LiA2PTExLTVcbmNvbnN0IFNISUZUXzFfMiA9IFNISUZUXzEgLSBTSElGVF8yO1xuXG4vLyBOdW1iZXIgb2YgaW5kZXgtMSBlbnRyaWVzIGZvciB0aGUgQk1QLiAzMj0weDIwXG4vLyBUaGlzIHBhcnQgb2YgdGhlIGluZGV4LTEgdGFibGUgaXMgb21pdHRlZCBmcm9tIHRoZSBzZXJpYWxpemVkIGZvcm0uXG5jb25zdCBPTUlUVEVEX0JNUF9JTkRFWF8xX0xFTkdUSCA9IDB4MTAwMDAgPj4gU0hJRlRfMTtcblxuLy8gTnVtYmVyIG9mIGVudHJpZXMgaW4gYW4gaW5kZXgtMiBibG9jay4gNjQ9MHg0MFxuY29uc3QgSU5ERVhfMl9CTE9DS19MRU5HVEggPSAxIDw8IFNISUZUXzFfMjtcblxuLy8gTWFzayBmb3IgZ2V0dGluZyB0aGUgbG93ZXIgYml0cyBmb3IgdGhlIGluLWluZGV4LTItYmxvY2sgb2Zmc2V0LiAqL1xuY29uc3QgSU5ERVhfMl9NQVNLID0gSU5ERVhfMl9CTE9DS19MRU5HVEggLSAxO1xuXG4vLyBTaGlmdCBzaXplIGZvciBzaGlmdGluZyBsZWZ0IHRoZSBpbmRleCBhcnJheSB2YWx1ZXMuXG4vLyBJbmNyZWFzZXMgcG9zc2libGUgZGF0YSBzaXplIHdpdGggMTYtYml0IGluZGV4IHZhbHVlcyBhdCB0aGUgY29zdFxuLy8gb2YgY29tcGFjdGFiaWxpdHkuXG4vLyBUaGlzIHJlcXVpcmVzIGRhdGEgYmxvY2tzIHRvIGJlIGFsaWduZWQgYnkgREFUQV9HUkFOVUxBUklUWS5cbmNvbnN0IElOREVYX1NISUZUID0gMjtcblxuLy8gTnVtYmVyIG9mIGVudHJpZXMgaW4gYSBkYXRhIGJsb2NrLiAzMj0weDIwXG5jb25zdCBEQVRBX0JMT0NLX0xFTkdUSCA9IDEgPDwgU0hJRlRfMjtcblxuLy8gTWFzayBmb3IgZ2V0dGluZyB0aGUgbG93ZXIgYml0cyBmb3IgdGhlIGluLWRhdGEtYmxvY2sgb2Zmc2V0LlxuY29uc3QgREFUQV9NQVNLID0gREFUQV9CTE9DS19MRU5HVEggLSAxO1xuXG4vLyBUaGUgcGFydCBvZiB0aGUgaW5kZXgtMiB0YWJsZSBmb3IgVStEODAwLi5VK0RCRkYgc3RvcmVzIHZhbHVlcyBmb3Jcbi8vIGxlYWQgc3Vycm9nYXRlIGNvZGUgX3VuaXRzXyBub3QgY29kZSBfcG9pbnRzXy5cbi8vIFZhbHVlcyBmb3IgbGVhZCBzdXJyb2dhdGUgY29kZSBfcG9pbnRzXyBhcmUgaW5kZXhlZCB3aXRoIHRoaXMgcG9ydGlvbiBvZiB0aGUgdGFibGUuXG4vLyBMZW5ndGg9MzI9MHgyMD0weDQwMD4+U0hJRlRfMi4gKFRoZXJlIGFyZSAxMDI0PTB4NDAwIGxlYWQgc3Vycm9nYXRlcy4pXG5jb25zdCBMU0NQX0lOREVYXzJfT0ZGU0VUID0gMHgxMDAwMCA+PiBTSElGVF8yO1xuY29uc3QgTFNDUF9JTkRFWF8yX0xFTkdUSCA9IDB4NDAwID4+IFNISUZUXzI7XG5cbi8vIENvdW50IHRoZSBsZW5ndGhzIG9mIGJvdGggQk1QIHBpZWNlcy4gMjA4MD0weDgyMFxuY29uc3QgSU5ERVhfMl9CTVBfTEVOR1RIID0gTFNDUF9JTkRFWF8yX09GRlNFVCArIExTQ1BfSU5ERVhfMl9MRU5HVEg7XG5cbi8vIFRoZSAyLWJ5dGUgVVRGLTggdmVyc2lvbiBvZiB0aGUgaW5kZXgtMiB0YWJsZSBmb2xsb3dzIGF0IG9mZnNldCAyMDgwPTB4ODIwLlxuLy8gTGVuZ3RoIDMyPTB4MjAgZm9yIGxlYWQgYnl0ZXMgQzAuLkRGLCByZWdhcmRsZXNzIG9mIFNISUZUXzIuXG5jb25zdCBVVEY4XzJCX0lOREVYXzJfT0ZGU0VUID0gSU5ERVhfMl9CTVBfTEVOR1RIO1xuY29uc3QgVVRGOF8yQl9JTkRFWF8yX0xFTkdUSCA9IDB4ODAwID4+IDY7ICAvLyBVKzA4MDAgaXMgdGhlIGZpcnN0IGNvZGUgcG9pbnQgYWZ0ZXIgMi1ieXRlIFVURi04XG5cbi8vIFRoZSBpbmRleC0xIHRhYmxlLCBvbmx5IHVzZWQgZm9yIHN1cHBsZW1lbnRhcnkgY29kZSBwb2ludHMsIGF0IG9mZnNldCAyMTEyPTB4ODQwLlxuLy8gVmFyaWFibGUgbGVuZ3RoLCBmb3IgY29kZSBwb2ludHMgdXAgdG8gaGlnaFN0YXJ0LCB3aGVyZSB0aGUgbGFzdCBzaW5nbGUtdmFsdWUgcmFuZ2Ugc3RhcnRzLlxuLy8gTWF4aW11bSBsZW5ndGggNTEyPTB4MjAwPTB4MTAwMDAwPj5TSElGVF8xLlxuLy8gKEZvciAweDEwMDAwMCBzdXBwbGVtZW50YXJ5IGNvZGUgcG9pbnRzIFUrMTAwMDAuLlUrMTBmZmZmLilcbi8vXG4vLyBUaGUgcGFydCBvZiB0aGUgaW5kZXgtMiB0YWJsZSBmb3Igc3VwcGxlbWVudGFyeSBjb2RlIHBvaW50cyBzdGFydHNcbi8vIGFmdGVyIHRoaXMgaW5kZXgtMSB0YWJsZS5cbi8vXG4vLyBCb3RoIHRoZSBpbmRleC0xIHRhYmxlIGFuZCB0aGUgZm9sbG93aW5nIHBhcnQgb2YgdGhlIGluZGV4LTIgdGFibGVcbi8vIGFyZSBvbWl0dGVkIGNvbXBsZXRlbHkgaWYgdGhlcmUgaXMgb25seSBCTVAgZGF0YS5cbmNvbnN0IElOREVYXzFfT0ZGU0VUID0gVVRGOF8yQl9JTkRFWF8yX09GRlNFVCArIFVURjhfMkJfSU5ERVhfMl9MRU5HVEg7XG5cbi8vIFRoZSBhbGlnbm1lbnQgc2l6ZSBvZiBhIGRhdGEgYmxvY2suIEFsc28gdGhlIGdyYW51bGFyaXR5IGZvciBjb21wYWN0aW9uLlxuY29uc3QgREFUQV9HUkFOVUxBUklUWSA9IDEgPDwgSU5ERVhfU0hJRlQ7XG5cbmNsYXNzIFVuaWNvZGVUcmllIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIGNvbnN0IGlzQnVmZmVyID0gKHR5cGVvZiBkYXRhLnJlYWRVSW50MzJCRSA9PT0gJ2Z1bmN0aW9uJykgJiYgKHR5cGVvZiBkYXRhLnNsaWNlID09PSAnZnVuY3Rpb24nKTtcblxuICAgIGlmIChpc0J1ZmZlciB8fCBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgLy8gcmVhZCBiaW5hcnkgZm9ybWF0XG4gICAgICBsZXQgdW5jb21wcmVzc2VkTGVuZ3RoO1xuICAgICAgaWYgKGlzQnVmZmVyKSB7XG4gICAgICAgIHRoaXMuaGlnaFN0YXJ0ID0gZGF0YS5yZWFkVUludDMyTEUoMCk7XG4gICAgICAgIHRoaXMuZXJyb3JWYWx1ZSA9IGRhdGEucmVhZFVJbnQzMkxFKDQpO1xuICAgICAgICB1bmNvbXByZXNzZWRMZW5ndGggPSBkYXRhLnJlYWRVSW50MzJMRSg4KTtcbiAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuaGlnaFN0YXJ0ID0gdmlldy5nZXRVaW50MzIoMCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZXJyb3JWYWx1ZSA9IHZpZXcuZ2V0VWludDMyKDQsIHRydWUpO1xuICAgICAgICB1bmNvbXByZXNzZWRMZW5ndGggPSB2aWV3LmdldFVpbnQzMig4LCB0cnVlKTtcbiAgICAgICAgZGF0YSA9IGRhdGEuc3ViYXJyYXkoMTIpO1xuICAgICAgfVxuXG4gICAgICAvLyBkb3VibGUgaW5mbGF0ZSB0aGUgYWN0dWFsIHRyaWUgZGF0YVxuICAgICAgZGF0YSA9IGluZmxhdGUoZGF0YSwgbmV3IFVpbnQ4QXJyYXkodW5jb21wcmVzc2VkTGVuZ3RoKSk7XG4gICAgICBkYXRhID0gaW5mbGF0ZShkYXRhLCBuZXcgVWludDhBcnJheSh1bmNvbXByZXNzZWRMZW5ndGgpKTtcblxuICAgICAgLy8gc3dhcCBieXRlcyBmcm9tIGxpdHRsZS1lbmRpYW5cbiAgICAgIHN3YXAzMkxFKGRhdGEpO1xuXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDMyQXJyYXkoZGF0YS5idWZmZXIpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHByZS1wYXJzZWQgZGF0YVxuICAgICAgKHsgZGF0YTogdGhpcy5kYXRhLCBoaWdoU3RhcnQ6IHRoaXMuaGlnaFN0YXJ0LCBlcnJvclZhbHVlOiB0aGlzLmVycm9yVmFsdWUgfSA9IGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGdldChjb2RlUG9pbnQpIHtcbiAgICBsZXQgaW5kZXg7XG4gICAgaWYgKChjb2RlUG9pbnQgPCAwKSB8fCAoY29kZVBvaW50ID4gMHgxMGZmZmYpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvclZhbHVlO1xuICAgIH1cblxuICAgIGlmICgoY29kZVBvaW50IDwgMHhkODAwKSB8fCAoKGNvZGVQb2ludCA+IDB4ZGJmZikgJiYgKGNvZGVQb2ludCA8PSAweGZmZmYpKSkge1xuICAgICAgLy8gT3JkaW5hcnkgQk1QIGNvZGUgcG9pbnQsIGV4Y2x1ZGluZyBsZWFkaW5nIHN1cnJvZ2F0ZXMuXG4gICAgICAvLyBCTVAgdXNlcyBhIHNpbmdsZSBsZXZlbCBsb29rdXAuICBCTVAgaW5kZXggc3RhcnRzIGF0IG9mZnNldCAwIGluIHRoZSBpbmRleC5cbiAgICAgIC8vIGRhdGEgaXMgc3RvcmVkIGluIHRoZSBpbmRleCBhcnJheSBpdHNlbGYuXG4gICAgICBpbmRleCA9ICh0aGlzLmRhdGFbY29kZVBvaW50ID4+IFNISUZUXzJdIDw8IElOREVYX1NISUZUKSArIChjb2RlUG9pbnQgJiBEQVRBX01BU0spO1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpbmRleF07XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgIC8vIExlYWQgU3Vycm9nYXRlIENvZGUgUG9pbnQuICBBIFNlcGFyYXRlIGluZGV4IHNlY3Rpb24gaXMgc3RvcmVkIGZvclxuICAgICAgLy8gbGVhZCBzdXJyb2dhdGUgY29kZSB1bml0cyBhbmQgY29kZSBwb2ludHMuXG4gICAgICAvLyAgIFRoZSBtYWluIGluZGV4IGhhcyB0aGUgY29kZSB1bml0IGRhdGEuXG4gICAgICAvLyAgIEZvciB0aGlzIGZ1bmN0aW9uLCB3ZSBuZWVkIHRoZSBjb2RlIHBvaW50IGRhdGEuXG4gICAgICBpbmRleCA9ICh0aGlzLmRhdGFbTFNDUF9JTkRFWF8yX09GRlNFVCArICgoY29kZVBvaW50IC0gMHhkODAwKSA+PiBTSElGVF8yKV0gPDwgSU5ERVhfU0hJRlQpICsgKGNvZGVQb2ludCAmIERBVEFfTUFTSyk7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhW2luZGV4XTtcbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50IDwgdGhpcy5oaWdoU3RhcnQpIHtcbiAgICAgIC8vIFN1cHBsZW1lbnRhbCBjb2RlIHBvaW50LCB1c2UgdHdvLWxldmVsIGxvb2t1cC5cbiAgICAgIGluZGV4ID0gdGhpcy5kYXRhWyhJTkRFWF8xX09GRlNFVCAtIE9NSVRURURfQk1QX0lOREVYXzFfTEVOR1RIKSArIChjb2RlUG9pbnQgPj4gU0hJRlRfMSldO1xuICAgICAgaW5kZXggPSB0aGlzLmRhdGFbaW5kZXggKyAoKGNvZGVQb2ludCA+PiBTSElGVF8yKSAmIElOREVYXzJfTUFTSyldO1xuICAgICAgaW5kZXggPSAoaW5kZXggPDwgSU5ERVhfU0hJRlQpICsgKGNvZGVQb2ludCAmIERBVEFfTUFTSyk7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhW2luZGV4XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGggLSBEQVRBX0dSQU5VTEFSSVRZXTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaWNvZGVUcmllOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/swap.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/swap.js ***!
  \*********************************************************************************/
/***/ ((module) => {

eval("const isBigEndian = (new Uint8Array(new Uint32Array([0x12345678]).buffer)[0] === 0x12);\n\nconst swap = (b, n, m) => {\n  let i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n};\n\nconst swap32 = array => {\n  const len = array.length;\n  for (let i = 0; i < len; i += 4) {\n    swap(array, i, i + 3);\n    swap(array, i + 1, i + 2);\n  }\n};\n\nconst swap32LE = array => {\n  if (isBigEndian) {\n    swap32(array);\n  }\n};\n\nmodule.exports = {\n  swap32LE: swap32LE\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vdW5pY29kZS10cmllQDIuMC4wL25vZGVfbW9kdWxlcy91bmljb2RlLXRyaWUvc3dhcC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL29iZWRrYWZmbHUvRG9jdW1lbnRzL0dpdEh1Yi9zZWVkY2x1Yi9ub2RlX21vZHVsZXMvLnBucG0vdW5pY29kZS10cmllQDIuMC4wL25vZGVfbW9kdWxlcy91bmljb2RlLXRyaWUvc3dhcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpc0JpZ0VuZGlhbiA9IChuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTIzNDU2NzhdKS5idWZmZXIpWzBdID09PSAweDEyKTtcblxuY29uc3Qgc3dhcCA9IChiLCBuLCBtKSA9PiB7XG4gIGxldCBpID0gYltuXTtcbiAgYltuXSA9IGJbbV07XG4gIGJbbV0gPSBpO1xufTtcblxuY29uc3Qgc3dhcDMyID0gYXJyYXkgPT4ge1xuICBjb25zdCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKGFycmF5LCBpLCBpICsgMyk7XG4gICAgc3dhcChhcnJheSwgaSArIDEsIGkgKyAyKTtcbiAgfVxufTtcblxuY29uc3Qgc3dhcDMyTEUgPSBhcnJheSA9PiB7XG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIHN3YXAzMihhcnJheSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzd2FwMzJMRTogc3dhcDMyTEVcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/swap.js\n");

/***/ })

};
;